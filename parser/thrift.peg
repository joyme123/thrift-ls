{
package parser

func toStringSlice(strs any) []string {
	if strs == nil {
		return nil
	}

	items := strs.([]any)
	ret := make([]string, 0, len(items))
	for i := range items {
		var item string
		if _, ok := items[i].([]interface{}); ok {
			data := items[i].([]interface{})[1]
			if bs, ok := data.([]uint8); ok {
				item = string(bs)
			} else {
				item = items[i].([]interface{})[1].(string)
			}
		} else {
			item = items[i].(string)
		}
		
		ret = append(ret, item)
	}

	return ret
}

func toFieldSlice(fields any) []*Field {
	if fields == nil {
		return nil
	}
	
	items := fields.([]any)
	ret := make([]*Field, 0, len(items))
	for i := range items {
		item := items[i].(*Field)
		ret = append(ret, item)
	}
	return ret
}

func toConstValueSlice(values any) []*ConstValue {
	if values == nil {
		return nil
	}

	items := values.([]any)
	ret := make([]*ConstValue, 0, len(items))
	for i := range items {
		item := items[i].(*ConstValue)
		ret = append(ret, item)
	}
	return ret
}

func toString(text any) string {
	if text == nil {
		return ""
	}

	data := text.([]interface{})
	
	ret := bytes.NewBuffer(nil)
	for i := range data {
		ret.WriteString(data[i].(string))
	}

	return ret.String()
}

func toHeaderSlice(headers any) []Header {
	if headers == nil {
		return nil
	}
	items := headers.([]any)
	ret := make([]Header, 0, len(items))
	for i := range items {
		ret = append(ret, items[i].(Header))
	}
	return ret
}

func toDefinitionSlice(defs any) []Definition {
	if defs == nil {
		return nil
	}
	items := defs.([]any)
	ret := make([]Definition, 0, len(items))
	for i := range items {
		ret = append(ret, items[i].(Definition))
	}
	return ret
}

func toEnumValueSlice(v any) []*EnumValue {
	if v == nil {
		return nil
	}
	values := v.([]any)

	ret := make([]*EnumValue, 0, len(values))
	value := int64(0)
	for i := range values {
		enumV := values[i].(*EnumValue)
		if enumV.ValueNode == nil {
			enumV.Value = value
		} else {
			value = enumV.Value
		}
		value++
		ret = append(ret, enumV)
	}
	return ret
}

func toFunctionSlice(fns any) []*Function {
	if fns == nil {
		return nil
	}
	items := fns.([]any)
	ret := make([]*Function, 0, len(items))
	for i := range items {
		ret = append(ret, items[i].(*Function))
	}
	return ret
}

}

Document = headers:Header*  defs:Definition* Skip !. {
	return NewDocument(toHeaderSlice(headers), toDefinitionSlice(defs), NewLocationFromCurrent(c)), nil
} //{errHeader} ErrHeader //{errDefinition} ErrDefinition

Header <- Skip v:(Include / CppInclude / Namespace) SkipLine {
	c.globalStore["parse"] = "header"
	return v, nil
} / x:(!(Definition) Skip &(.+) &{
	/* fmt.Println("header predict:", c.pos, "text:", string(c.text)) */
	if state, ok := c.globalStore["parse"]; (!ok || ok && state.(string) == "header") {
		return true, nil
	}
	return false, nil
} %{errHeader}) {
	/* fmt.Println("header return:", c.pos, "text:", string(c.text)) */
	badHeader := x.([]any)[4].(*BadHeader)
	return badHeader, nil
} //{errInclude} ErrInclude //{errCppInclude} ErrorCppInclude //{errNamespace} ErrorNamespace

Include <- INCLUDE include:Literal {
	includeV, ok := include.(*Literal)
	if !ok {
		includeV = include.([]interface{})[0].(*Literal)
	}
	return NewInclude(includeV, NewLocationFromCurrent(c)), nil
} / x:(&(INCLUDE .*) %{errInclude}) {
	return x.([]any)[1], nil
}


CppInclude <- CPPINCLUDE include:Literal {
	includeV, ok := include.(*Literal)
	if !ok {
		includeV = include.([]interface{})[0].(*Literal)
	}
	return NewCPPInclude(includeV, NewLocationFromCurrent(c)), nil
} / x:(&(CPPINCLUDE .*) %{errCppInclude}) {
	return x.([]any)[1], nil
}


Namespace <- NAMESPACE language:NamespaceScope name:Identifier Annotations? {
	var lang string
	id, ok := language.(*Identifier)
	if ok {
		lang = id.Name
	} else {
		lang = "*"
	}
	return NewNamespace(lang, name.(*Identifier).Name, NewLocationFromCurrent(c)), nil
} / x:(&(NAMESPACE .*) %{errNamespace}) {
	return x.([]any)[1], nil
}

NamespaceScope <- Skip
    '*' Indent*
    / Identifier

Definition = comments:ReservedComments Skip v:(Const / Typedef / Enum / Service / Struct / Union / Exception) Annotations? SkipLine {
	c.globalStore["parse"] = "definition"
	def := v.(Definition)
	def.SetComments(comments.(string))
	return def, nil
} / x:(Skip &(.+) &{
	/* fmt.Println("definition predict:", c.pos, "text:", string(c.text)) */
	if state, ok := c.globalStore["parse"]; ok && state.(string) == "definition" {
		return true, nil
	}
	return false, nil
} %{errDefinition}) {
	/* fmt.Println("definition return:", c.pos, "text:", string(c.text)) */
	return x.([]any)[3], nil
} //{errConst} ErrConst //{errTypedef} ErrTypedef //{errEnum} ErrEnum //{errService} ErrService //{errStruct} ErrStruct //{errUnion} ErrUnion //{errException} ErrException

Const = CONST t:FieldType name:Identifier EQUAL v:ConstValue ListSeparator? {
	return NewConst(name.(*Identifier), t.(*FieldType), v.(*ConstValue), "", NewLocationFromCurrent(c)), nil
} / x:(&(CONST .*)) %{errConst} {
	return x.([]any)[1], nil
}

Typedef <- TYPEDEF t:FieldType alias:Identifier {
	return NewTypedef(t.(*FieldType), alias.(*Identifier), NewLocationFromCurrent(c)), nil
} / x:(&(TYPEDEF .*) %{errTypedef}) {
	return x.([]any)[1], nil
}

Enum  <- ENUM name:Identifier LCUR v:EnumValueLine* RCUR {
	values := toEnumValueSlice(v)
	return NewEnum(name.(*Identifier), values, NewLocationFromCurrent(c)), nil
} / x:(&(ENUM .*) %{errEnum}) {
	return x.([]any)[1], nil
}

EnumValueLine = comments:ReservedComments v:EnumValue SkipLine {
        v.(*EnumValue).Comments = comments.(string)
	return v, nil
}

EnumValue =  name:Identifier value:(EQUAL IntConstant)? Annotations? ListSeparator? {
	var valueNode *ConstValue
	intV := int64(-1)
	if value != nil {
		valueNode = value.([]any)[1].(*ConstValue)
		intV = value.([]any)[1].(*ConstValue).Value.(int64)
	}

	return NewEnumValue(name.(*Identifier), valueNode, intV, "", NewLocationFromCurrent(c)), nil
}

Service <- SERVICE name:Identifier extends:( EXTENDS Identifier )? LCUR fns:Function* RCUR {
	var extendsVal *Identifier
	if extends != nil {
		extendsVal = extends.(*Identifier)
	}
	fnsVal := toFunctionSlice(fns)
	return NewService(name.(*Identifier), extendsVal, fnsVal, NewLocationFromCurrent(c)), nil
} / x:(&(SERVICE .*) %{errService}) {
	return x.([]any)[1], nil
}

Struct = STRUCT id:StructIdentifier LCUR fields:FieldWithThrow* RCUR {
	return NewStruct(id.(*Identifier), toFieldSlice(fields), NewLocationFromCurrent(c)), nil
} / x:(&(STRUCT .*) %{errStruct}) {
	return x.([]any)[1], nil
} //{errStructIdentifier} ErrStructIdentifier //{errRCUR} ErrStructRCUR  //{errField} ErrStructField

Union <- UNION name:UnionIdentifier LCUR fields:FieldWithThrow* RCUR {
	return NewUnion(name.(*Identifier), toFieldSlice(fields), NewLocationFromCurrent(c)), nil
} / x:(&(UNION .*) %{errUnion}) {
	return x.([]any)[1], nil
} //{errUnionIdentifier} ErrUnionIdentifier //{errRCUR} ErrUnionRCUR //{errField} ErrUnionField


Exception <- EXCEPTION name:Identifier LCUR fields:Field* RCUR {
	return NewException(name.(*Identifier), toFieldSlice(fields), NewLocationFromCurrent(c)), nil
} / x:(&(EXCEPTION .*) %{errException}) {
	return x.([]any)[1], nil
}


FieldWithThrow = Field / x:( Skip !(( '}' Indent*) / DefinitionStart ) %{errField} ) {
	return x.([]any)[2], nil
}

Field = comments:ReservedComments Skip index:FieldId required:FieldReq? fieldType:FieldType id:Identifier value:(EQUAL ConstValue)? Annotations? ListSeparator? lineComments:ReservedEndLineComments SkipLine {
        var constV *ConstValue
	if value !=  nil {
	   constV = value.([]interface{})[1].(*ConstValue)
	}
	var requiredV *Required
	if required != nil {
		requiredV = required.(*Required)
	}

	return NewField(comments.(string), lineComments.(string), index.(*FieldIndex), requiredV, fieldType.(*FieldType), id.(*Identifier), constV, NewLocationFromCurrent(c)), nil
}


FieldId = Skip i:FieldIndex COLON Indent* {
	return i, nil
} //{errFieldIndex} ErrFieldIndex

FieldReq = Skip r:IsRequired Indent* {
	if r == nil {
		return nil, nil
	}
	return r.(*Required), nil
}
IsRequired = v:("required" / "optional") {
	if v == nil {
		return nil, nil
	}
	return NewRequired(string(v.([]byte)) == "required", c.pos), nil
}

Function = comments:ReservedComments Skip oneway:ONEWAY? ft:FunctionType name:Identifier LPAR args:Field* RPAR throws:Throws? Annotations? ListSeparator? SkipLine {
	void := false
	var ftype *FieldType
	if str, ok := ft.(string); ok && str == "void" {
		void = true
	} else {
		ftype = ft.(*FieldType) 
	}

	var throwsFields []*Field
	if throws != nil {
		throwsFields = throws.([]*Field)
	}
	return NewFunction(name.(*Identifier), oneway != nil, void, ftype, toFieldSlice(args), throwsFields, comments.(string), NewLocationFromCurrent(c)), nil
}

FunctionType  <- VOID / FieldType

Throws <- THROWS LPAR fields:Field* RPAR {
	return toFieldSlice(fields), nil
}

FieldType  = v:(ContainerType / BaseType / IdentifierType) Annotations? {
	return v.(*FieldType), nil
}

IdentifierType = v:Identifier {
	return v.(*Identifier).ToFieldType(), nil
}

BaseType = v:(BOOL / BYTE / I8 / I16 / I32 / I64 / DOUBLE / STRING / BINARY) {
	return NewFieldType(v.(*TypeName), nil, nil, NewLocationFromCurrent(c)), nil
}

ContainerType = v:(MapType / SetType / ListType) {
	return v.(*FieldType), nil
}

MapType =  t:MAP CppType? LPOINT key:FieldType COMMA value:FieldType RPOINT {
	return NewFieldType(t.(*TypeName), key.(*FieldType), value.(*FieldType), NewLocationFromCurrent(c)), nil
}

SetType = t:SET CppType? LPOINT key:FieldType RPOINT {
	return NewFieldType(t.(*TypeName), key.(*FieldType), nil, NewLocationFromCurrent(c)), nil
}

ListType = t:LIST LPOINT key:FieldType RPOINT CppType? {
	return NewFieldType(t.(*TypeName), key.(*FieldType), nil, NewLocationFromCurrent(c)), nil
}

CppType = CPPTYPE Literal

ConstValue = v:(DoubleConstant / IntConstant / Literal / IdentifierConst / ConstMap / ConstList ) {
	if str, ok := v.(*Literal); ok {
		return NewConstValue("string", str.Value, NewLocationFromCurrent(c)), nil
	}
	return v.(*ConstValue), nil
}

IdentifierConst = id:Identifier {
	return NewConstValue("identifier", id.(*Identifier).Name, NewLocationFromCurrent(c)), nil
}

IntConstant = Skip  v:(HexIntConstant / OctIntConstant / NormalIntConstant)  Indent* {
	return v.(*ConstValue), nil
}

HexIntConstant = "0x" ([0-9] / [A-Z] / [a-z])+ {
        v, err := strconv.ParseInt(strings.TrimLeft(string(c.text), "0x"), 16, 64)
	if err != nil {
		return nil, err
	}

	return NewConstValue("i64", v, NewLocationFromCurrent(c)), nil
}

OctIntConstant = "0o" Digit+ {
	v, err := strconv.ParseInt(strings.TrimLeft(string(c.text), "0o"), 8, 64)
	if err != nil {
		return nil, err
	}
	return NewConstValue("i64", v, NewLocationFromCurrent(c)), nil
}

NormalIntConstant = ('+' / '-')? Digit+ {
	v, err := strconv.ParseInt(string(c.text), 10, 64)
	if err != nil {
		return nil, err
	}
	return NewConstValue("i64", v, NewLocationFromCurrent(c)), nil
}

FieldIndex = Digit+ {
	v, err := strconv.ParseInt(string(c.text), 10, 64)
	if err != nil {
		return nil, err
	}
	return NewFieldIndex(int(v), NewLocationFromCurrent(c)), nil
} / x:(Skip &([a-zA-Z]+ COLON) %{errFieldIndex}) {
	return x.([]any)[2], nil
}

DoubleConstant  = Skip ('+' / '-')? v:(
        Digit* '.' Digit+  Exponent?
    /   Digit+ Exponent
    ) Indent* {
    	v, err := strconv.ParseFloat(string(c.text), 64)
	if err != nil {
		return nil, err
	}
    	return NewConstValue("double", v, NewLocationFromCurrent(c)), nil
    }

Exponent = ('e' / 'E') IntConstant

Annotations <- LPAR Annotation+ RPAR

Annotation <- Identifier EQUAL Literal ListSeparator?

ConstList  = LBRK v:ConstListItem* RBRK {
	return NewConstValue("list", toConstValueSlice(v), NewLocationFromCurrent(c)), nil
}

ConstListItem = v:ConstValue ListSeparator? {
	return v.(*ConstValue), nil
}

ConstMap  = LCUR v:ConstMapItem* RCUR {
	return NewConstValue("map", toConstValueSlice(v), NewLocationFromCurrent(c)), nil
}

ConstMapItem = key:ConstValue COLON value:ConstValue ListSeparator? {
	return NewMapConstValue(key.(*ConstValue), value.(*ConstValue), NewLocationFromCurrent(c)), nil
}

EscapeLiteralChar = '\\' ["'] {
	return string(c.text), nil
}

Literal = l:(Literal1 / Literal2) {
	return l, nil
} //{errLiteral1MissingRight} ErrLiteral1MissingRight //{errLiteral1} ErrLiteral1 //{errLiteral2MissingRight} ErrLiteral2MissingRight //{errLiteral2} ErrLiteral2

Literal1 = Skip '"' t:(EscapeLiteralChar / !'"' .)* '"' Indent* {
	strs := toStringSlice(t)
	return NewLiteral(strings.Join(strs, ""), NewLocationFromCurrent(c)), nil
} / x:(&(Skip '"' t:(EscapeLiteralChar / !'"' .)* Indent*) %{errLiteral1MissingRight}) {
	 return x.([]any)[1], nil 
}

Literal2 = Skip "'" t:(EscapeLiteralChar / !"'" .)* "'" Indent* {
	strs := toStringSlice(t)
	return NewLiteral(strings.Join(strs, ""), NewLocationFromCurrent(c)), nil
} / x:(&(Skip "'" t:(EscapeLiteralChar / !"'" .)* Indent*) %{errLiteral2MissingRight}) {
	 return x.([]any)[1], nil 
}

StructIdentifier = id:Identifier {
	return id.(*Identifier), nil
} / %{errStructIdentifier}

UnionIdentifier = id:Identifier {
	return id.(*Identifier), nil
} / %{errUnionIdentifier}

Identifier = Skip id:IdentifierToken Indent* {
	return id.(*Identifier), nil
}

IdentifierToken = Letter ( Letter / Digit / '.' )* {
	return NewIdentifier(string(c.text), c.pos), nil
} 

ListSeparator = Skip (',' / ';') Indent*

Letter = [A-Z] / [a-z] / '_' {
	return string(c.text), nil
}
LetterOrDigit = [a-z] / [A-Z] / [0-9] / [_$] {
	return string(c.text), nil
}

Digit = [0-9] {
	return string(c.text), nil
}

ReservedComments = Skip 
ReservedEndLineComments = SkipLine

Skip = comments:(Space / Comment)* {
	return strings.Join(toStringSlice(comments), "\n"), nil
}
SkipLine = comments:(Indent / Comment)* {
	return strings.Join(toStringSlice(comments), "\n"), nil
}

Space = (Indent / CarriageReturnLineFeed)+ {
	return "", nil
}
Indent = [ \t\v] {
	return "", nil
}
CarriageReturnLineFeed = [\r\n]

Comment = v:(LongComment / LineComment / UnixComment) {
	return v.(string), nil
}
LongComment = "/*" comment:LongCommentMatch "*/" {
	return comment.(string), nil
}
LongCommentMatch = (!"*/" .)* {
	return string(c.text), nil
}

LineComment = "//" comment:LineCommentMatch {
	return comment.(string), nil
}
LineCommentMatch = (![\r\n] .)* {
	return string(c.text), nil
}

UnixComment = '#' comment:UnixCommentMatch {
	return comment.(string), nil
}
UnixCommentMatch = (![\r\n] .)*  {
	return string(c.text), nil
}

BOOL        = Skip t:BOOLToken        !LetterOrDigit  Indent* {
	return t.(*TypeName), nil
}
BOOLToken  = "bool" {
	return NewTypeName(string(c.text), c.pos), nil
}

BYTE        = Skip t:BYTEToken        !LetterOrDigit  Indent* {
	return t.(*TypeName), nil
}
BYTEToken = "byte" {
	return NewTypeName(string(c.text), c.pos), nil
}

I8          = Skip t:I8Token          !LetterOrDigit  Indent* {
	return t.(*TypeName), nil
}
I8Token = "i8" {
	return NewTypeName(string(c.text), c.pos), nil
}


I16         = Skip t:I16Token         !LetterOrDigit  Indent* {
	return t.(*TypeName), nil
}
I16Token = "i16" {
	return NewTypeName(string(c.text), c.pos), nil
}

I32         = Skip t:I32Token         !LetterOrDigit  Indent* {
	return t.(*TypeName), nil
}
I32Token = "i32" {
	return NewTypeName(string(c.text), c.pos), nil
}

I64         = Skip t:I64Token         !LetterOrDigit  Indent* {
	return t.(*TypeName), nil
}
I64Token = "i64" {
	return NewTypeName(string(c.text), c.pos), nil
}

DOUBLE      = Skip t:DOUBLEToken      !LetterOrDigit  Indent* {
	return t.(*TypeName), nil
}
DOUBLEToken = "double" {
	return NewTypeName(string(c.text), c.pos), nil
}

STRING      = Skip t:STRINGToken      !LetterOrDigit  Indent* {
	return t.(*TypeName), nil
}
STRINGToken = "string" {
	return NewTypeName(string(c.text), c.pos), nil
}

BINARY      = Skip t:BINARYToken      !LetterOrDigit  Indent* {
	return t.(*TypeName), nil
}
BINARYToken = "binary" {
	return NewTypeName(string(c.text), c.pos), nil
}

CONST       = Skip t:CONSTToken         !LetterOrDigit  Indent* {
	return t.(*TypeName), nil
}
CONSTToken = "const" {
	return NewTypeName(string(c.text), c.pos), nil
}

ONEWAY      = Skip t:ONEWAYToken        !LetterOrDigit  Indent* {
	return t.(*TypeName), nil
}
ONEWAYToken = "oneway" {
	return NewTypeName(string(c.text), c.pos), nil
}

TYPEDEF     = Skip "typedef"       !LetterOrDigit  Indent* {
	return "typedef", nil
}
MAP         = Skip t:MAPToken           !LetterOrDigit  Indent* {
	return t.(*TypeName), nil
}
MAPToken = "map" {
	return NewTypeName(string(c.text), c.pos), nil
}

SET         = Skip t:SETToken           !LetterOrDigit  Indent* {
	return t.(*TypeName), nil
}
SETToken = "set" {
	return NewTypeName(string(c.text), c.pos), nil
}

LIST        = Skip t:ListToken          !LetterOrDigit  Indent* {
	return t.(*TypeName), nil
}
ListToken = "list" {
	return NewTypeName(string(c.text), c.pos), nil
}

VOID        = Skip "void"          !LetterOrDigit  Indent* {
	return "void", nil
}
THROWS      = Skip "throws"        !LetterOrDigit  Indent* {
	return "throws", nil
}
EXCEPTION   = Skip "exception"     !LetterOrDigit  Indent* {
	return "exception", nil
}
EXTENDS     = Skip "extends"       !LetterOrDigit  Indent* {
	return "extends", nil
}
SERVICE     = Skip "service"       !LetterOrDigit  Indent* {
	return "service", nil
}
STRUCT      = Skip "struct"        !LetterOrDigit  Indent* {
	return "struct", nil
}
UNION       = Skip "union"         !LetterOrDigit  Indent* {
	return "union", nil
}
ENUM        = Skip "enum"          !LetterOrDigit  Indent* {
	return "enum", nil
}
INCLUDE     = Skip "include"       !LetterOrDigit  Indent* {
	return "include", nil
}
CPPINCLUDE  = Skip "cpp_include"   !LetterOrDigit  Indent* {
	return "cpp_include", nil
}
NAMESPACE   = Skip "namespace"     !LetterOrDigit  Indent* {
	return "namespace", nil
}
CPPTYPE     = Skip "cpp_type"      !LetterOrDigit  Indent* {
	return "cpp_type", nil
}
LBRK        = Skip "["     Indent* {
	return "[", nil
}
RBRK        = Skip "]"     Indent* {
	return "]", nil
}
LCUR       = Skip t:LCURToken     Indent* {
	return t.(string), nil
}
RCUR       = Skip t:RCURToken     Indent* {
	return t.(string), nil
}
LCURToken = "{" {
	return string(c.text), nil
}
RCURToken = "}" {
	return string(c.text), nil
} / %{errRCUR}
EQUAL       = Skip "="     Indent* {
	return "=", nil
}
LPOINT      = Skip "<"     Indent* {
	return "<", nil
}
RPOINT      = Skip ">"     Indent* {
	return ">", nil
}
COMMA       = Skip ","     Indent* {
	return ",", nil
}
LPAR        = Skip "("     Indent* {
	return "(", nil
}
RPAR        = Skip ")"     Indent* {
	return ")", nil
}
COLON       = Skip ":"     Indent* {
	return ":", nil
}

DefinitionStart = STRUCT / UNION / EXCEPTION / ENUM / SERVICE / CONST / TYPEDEF

ErrStructField = #{
	return InvalidStructFieldError
} ( !(Field / (Skip '}' Indent*) / DefinitionStart ) . )* {
	return NewField("", "", nil, nil, nil, nil, nil, NewLocationFromCurrent(c)), nil
}

ErrFieldIndex = #{
	return InvalidFieldIndexError
} (!([:\r\n]) .)* { // 消费到冒号或本行结束
	return NewBadFieldIndex(NewLocationFromCurrent(c)), nil
}

ErrStructIdentifier = #{
	return InvalidStructIdentifierError
} ( !'{' .)* { // struct identifier 异常，consume 掉异常字符直到出现 '{' 为止
	t := NewIdentifier("", c.pos)
	t.BadNode = true

	return t, nil
} // 构造 identifier 的 badnode


ErrStructRCUR = #{
	return InvalidStructBlockRCURError
} ( !DefinitionStart .)* { // 缺少 '}'，消费异常字符直到出现下一个 definition。TODO(jpf): 后面会加入 typedef 等定义，需要扩展补充
	return "?", nil
}

ErrStructLCUR = #{
	return InvalidStructBlockLCURError
} ( !'}' .)* { // 缺少 '{'，消费异常字符直到出现下一个 Field 或者 '}'
	return "?", nil
}

ErrUnionIdentifier = #{
	return InvalidUnionIdentifierError
} ( !'{' .)* { // struct identifier 异常，consume 掉异常字符直到出现 '{' 为止
	t := NewIdentifier("", c.pos)
	t.BadNode = true

	return t, nil
}

ErrUnionRCUR = #{
	return InvalidUnionBlockRCURError
} ( !DefinitionStart .)* {
	return "?", nil
}

ErrUnionLCUR = #{
	return InvalidUnionBlockLCURError
} ( !'}' .)* { // 缺少 '{'，消费异常字符直到出现下一个 Field 或者 '}'
	return "?", nil
}

ErrUnionField = #{
	return InvalidUnionFieldError
} ( !(Field / (Skip '}' Indent*) / DefinitionStart ) . )* {
	return NewField("", "", nil, nil, nil, nil, nil, NewLocationFromCurrent(c)), nil
}

ErrLiteral1MissingRight = #{
	return InvalidLiteral1MissingRightError
} ( ![\r\n] .)* { // 消费异常字符直到这行结束
	return NewBadLiteral(string(c.text), NewLocationFromCurrent(c)), nil
}


ErrLiteral1 = #{
	return InvalidLiteral1Error
} ( ![\r\n] .)* { // 消费异常字符直到这行结束
	return NewBadLiteral(string(c.text), NewLocationFromCurrent(c)), nil
}

ErrLiteral2MissingRight = #{
	return InvalidLiteral2MissingRightError
} ( ![\r\n] .)* { // 消费异常字符直到这行结束
	return NewBadLiteral(string(c.text), NewLocationFromCurrent(c)), nil
}

ErrLiteral2 = #{
	return InvalidLiteral2Error
} ( ![\r\n] .)* { // 消费异常字符直到这行结束
	return NewBadLiteral(string(c.text), NewLocationFromCurrent(c)), nil
}

ErrConst = #{
	return InvalidConstError
} (![\r\n] .)* { // 消费异常字符直到这行结束
	return NewBadConst(NewLocationFromCurrent(c)), nil
}

ErrTypedef = #{
	return InvalidTypedefError
} (![\r\n] .)* { // 消费异常字符直到这行结束
	return NewBadTypedef(NewLocationFromCurrent(c)), nil
} 

ErrEnum = #{
	return InvalidEnumError
} (![\r\n] .)* { // 消费异常字符直到这行结束
	return NewBadEnum(NewLocationFromCurrent(c)), nil
} 

ErrService = #{
	return InvalidServiceError
} (![\r\n] .)* { // 消费异常字符直到这行结束
	return NewBadService(NewLocationFromCurrent(c)), nil
} 

ErrStruct = #{
	return InvalidStructError
} (![\r\n] .)* { // 消费异常字符直到这行结束
	return NewBadStruct(NewLocationFromCurrent(c)), nil
} 

ErrUnion = #{
	return InvalidUnionError
} (![\r\n] .)* { // 消费异常字符直到这行结束
	return NewBadUnion(NewLocationFromCurrent(c)), nil
} 

ErrException = #{
	return InvalidExceptionError
} (![\r\n] .)* { // 消费异常字符直到这行结束
	return NewBadException(NewLocationFromCurrent(c)), nil
} 

ErrDefinition = #{
	return InvalidDefinitionError
} (![\r\n] .)* { // 消费异常字符直到这行结束
	return NewBadDefinition(NewLocationFromCurrent(c)), nil
}

ErrInclude = #{
	return InvalidIncludeError
} (![\r\n] .)* { // 消费异常字符直到这行结束
	return NewBadInclude(NewLocationFromCurrent(c)), nil
}

ErrCppInclude = #{
	return InvalidCppIncludeError
} (![\r\n] .)* { // 消费异常字符直到这行结束
	return NewBadCPPInclude(NewLocationFromCurrent(c)), nil
}

ErrNamespace = #{
	return InvalidNamespaceError
} (![\r\n] .)* { // 消费异常字符直到这行结束
	return NewBadNamespace(NewLocationFromCurrent(c)), nil
}

ErrHeader = #{
	return InvalidHeaderError
} (![\r\n] .)* { // 消费异常字符直到这行结束
	return NewBadHeader(NewLocationFromCurrent(c)), nil
}
