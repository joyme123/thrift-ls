{
package parser

func toStringSlice(strs any) []string {
	if strs == nil {
		return nil
	}

	items := strs.([]any)
	ret := make([]string, 0, len(items))
	for i := range items {
		var item string
		if _, ok := items[i].([]interface{}); ok {
			data := items[i].([]interface{})[1]
			if bs, ok := data.([]uint8); ok {
				item = string(bs)
			} else {
				item = items[i].([]interface{})[1].(string)
			}
		} else {
			item = items[i].(string)
		}
		
		ret = append(ret, item)
	}

	return ret
}

func toFieldSlice(fields any) []*Field {
	if fields == nil {
		return nil
	}
	
	items := fields.([]any)
	ret := make([]*Field, 0, len(items))
	for i := range items {
		item := items[i].(*Field)
		ret = append(ret, item)
	}
	return ret
}

func toConstValueSlice(values any) []*ConstValue {
	if values == nil {
		return nil
	}

	items := values.([]any)
	ret := make([]*ConstValue, 0, len(items))
	for i := range items {
		item := items[i].(*ConstValue)
		ret = append(ret, item)
	}
	return ret
}

func toString(text any) string {
	if text == nil {
		return ""
	}

	data := text.([]interface{})
	
	ret := bytes.NewBuffer(nil)
	for i := range data {
		ret.WriteString(data[i].(string))
	}

	return ret.String()
}

func toDefinitionSlice(defs any) []Definition {
	if defs == nil {
		return nil
	}
	items := defs.([]any)
	ret := make([]Definition, 0, len(items))
	for i := range items {
		ret = append(ret, items[i].(Definition))
	}
	return ret
}

func toEnumValueSlice(v any) []*EnumValue {
	if v == nil {
		return nil
	}
	values := v.([]any)

	ret := make([]*EnumValue, 0, len(values))
	value := int64(0)
	for _, v := range values {
		fields := v.([]any)
		comments := fields[0].(string)
		name := fields[1].(*Identifier)
		valuePair := fields[2]
		if valuePair != nil {
			value = valuePair.([]any)[1].(*ConstValue).Value.(int64)
		}

		enumValue := NewEnumValue(name, value, comments)
		value++
		ret = append(ret, enumValue)
	}
	return ret
}

func toFunctionSlice(fns any) []*Function {
	if fns == nil {
		return nil
	}
	items := fns.([]any)
	ret := make([]*Function, 0, len(items))
	for i := range items {
		ret = append(ret, items[i].(*Function))
	}
	return ret
}

}

Document = Header*  def:Definition* Skip !. {
	return NewDocument(toDefinitionSlice(def)), nil
}

Header <- Skip (Include / CppInclude / Namespace) SkipLine

Include <- INCLUDE Literal

CppInclude <- CPPINCLUDE Literal

Namespace <- NAMESPACE NamespaceScope Identifier Annotations?

NamespaceScope <- Skip
    '*' Indent*
    / Identifier

Definition = comments:ReservedComments Skip v:(Const / Typedef / Enum / Service / Struct / Union / Exception) Annotations? SkipLine {
	def := v.(Definition)
	def.SetComments(comments.(string))
	return def, nil
}

Const <- CONST t:FieldType name:Identifier EQUAL v:ConstValue ListSeparator? {
	return NewConst(name.(*Identifier), t.(*FieldType), v.(*ConstValue), ""), nil
}

Typedef <- TYPEDEF t:FieldType alias:Identifier {
	return NewTypedef(t.(*FieldType), alias.(*Identifier)), nil
}

Enum  <- ENUM name:Identifier LCUR v:(ReservedComments Identifier (EQUAL IntConstant)? Annotations? ListSeparator? SkipLine)* RCUR {
	values := toEnumValueSlice(v)
	return NewEnum(name.(*Identifier), values), nil
}

Service <- SERVICE name:Identifier extends:( EXTENDS Identifier )? LCUR fns:Function* RCUR {
	var extendsVal *Identifier
	if extends != nil {
		extendsVal = extends.(*Identifier)
	}
	fnsVal := toFunctionSlice(fns)
	return NewService(name.(*Identifier), extendsVal, fnsVal), nil
}

Struct = STRUCT id:StructIdentifier LCUR fields:FieldWithThrow* RCUR {
	return NewStruct(id.(*Identifier), toFieldSlice(fields)), nil
} //{errIdentifier} ErrStructIdentifier //{errRCUR} ErrStructRCUR  //{errField} ErrField

Union <- UNION name:Identifier LCUR fields:Field* RCUR {
	return NewUnion(name.(*Identifier), toFieldSlice(fields)), nil
}

Exception <- EXCEPTION name:Identifier LCUR fields:Field* RCUR {
	return NewException(name.(*Identifier), toFieldSlice(fields)), nil
}

FieldWithThrow = Field / x:( !((Skip '}' Indent*) / STRUCT / CONST / TYPEDEF / ENUM / SERVICE / UNION / EXCEPTION) %{errField} ) {
	return x.([]any)[1], nil
}

Field = comments:ReservedComments Skip index:FieldId required:FieldReq? fieldType:FieldType id:Identifier value:(EQUAL ConstValue)? Annotations? ListSeparator? lineComments:ReservedEndLineComments SkipLine {
        var constV *ConstValue
	if value !=  nil {
	   constV = value.([]interface{})[1].(*ConstValue)
	}
	var requiredV *Required
	if required != nil {
		requiredV = required.(*Required)
	}

	return NewField(comments.(string), lineComments.(string), int(index.(int64)), requiredV, fieldType.(*FieldType), id.(*Identifier), constV), nil
}


FieldId = Skip i:FieldIndex COLON Indent* {
	return i, nil
} 
FieldReq = Skip r:IsRequired Indent* {
	if r == nil {
		return nil, nil
	}
	return r.(*Required), nil
}
IsRequired = v:("required" / "optional") {
	if v == nil {
		return nil, nil
	}
	return NewRequired(string(v.([]byte)) == "required", c.pos), nil
}

Function  <- comments:ReservedComments Skip oneway:ONEWAY? ft:FunctionType name:Identifier LPAR args:Field* RPAR throws:Throws? Annotations? ListSeparator? SkipLine {
	void := false
	var ftype *FieldType
	if str, ok := ft.(string); ok && str == "void" {
		void = true
	} else {
		ftype = ft.(*FieldType) 
	}
	var throwsFields []*Field
	if throws != nil {
		throwsFields = throws.([]*Field)
	}
	return NewFunction(name.(*Identifier), oneway != nil, void, ftype, toFieldSlice(args), throwsFields, comments.(string)), nil
}

FunctionType  <- VOID / FieldType

Throws <- THROWS LPAR fields:Field* RPAR {
	return toFieldSlice(fields), nil
}

FieldType  = v:(ContainerType / BaseType / IdentifierType) Annotations? {
	return v.(*FieldType), nil
}

IdentifierType = v:Identifier {
	return v.(*Identifier).ToFieldType(), nil
}

BaseType = v:(BOOL / BYTE / I8 / I16 / I32 / I64 / DOUBLE / STRING / BINARY) {
	return NewFieldType(v.(*TypeName), nil, nil), nil
}

ContainerType = v:(MapType / SetType / ListType) {
	return v.(*FieldType), nil
}

MapType =  t:MAP CppType? LPOINT key:FieldType COMMA value:FieldType RPOINT {
	return NewFieldType(t.(*TypeName), key.(*FieldType), value.(*FieldType)), nil
}

SetType = t:SET CppType? LPOINT key:FieldType RPOINT {
	return NewFieldType(t.(*TypeName), key.(*FieldType), nil), nil
}

ListType = t:LIST LPOINT key:FieldType RPOINT CppType? {
	return NewFieldType(t.(*TypeName), key.(*FieldType), nil), nil
}

CppType = CPPTYPE Literal

ConstValue = v:(DoubleConstant / IntConstant / Literal / IdentifierConst / ConstMap / ConstList ) {
	if str, ok := v.(string); ok {
		fmt.Println("constvalue string", v)
		return NewConstValue("string", str), nil
	}
	fmt.Println("constvalue", v)
	return v.(*ConstValue), nil
}

IdentifierConst = id:Identifier {
	return NewConstValue("identifier", id.(*Identifier).Name), nil
}

IntConstant = Skip  v:(HexIntConstant / OctIntConstant / NormalIntConstant)  Indent* {
	return v.(*ConstValue), nil
}

HexIntConstant = "0x" ([0-9] / [A-Z] / [a-z])+ {
        v, err := strconv.ParseInt(string(c.text), 16, 64)
	if err != nil {
		return nil, err
	}

	return NewConstValue("i64", v), nil
}

OctIntConstant = "0o" Digit+ {
	v, err := strconv.ParseInt(string(c.text), 8, 64)
	if err != nil {
		return nil, err
	}
	return NewConstValue("i64", v), nil
}

NormalIntConstant = ('+' / '-')? Digit+ {
	v, err := strconv.ParseInt(string(c.text), 10, 64)
	if err != nil {
		return nil, err
	}
	return NewConstValue("i64", v), nil
}

FieldIndex = Digit+ {
	v, err := strconv.ParseInt(string(c.text), 10, 64)
	if err != nil {
		return nil, err
	}
	return v, nil
} / %{errFieldIndex}

DoubleConstant  = Skip ('+' / '-')? v:(
        Digit* '.' Digit+  Exponent?
    /   Digit+ Exponent
    ) Indent* {
    	v, err := strconv.ParseFloat(string(c.text), 64)
	if err != nil {
		return nil, err
	}
    	return NewConstValue("double", v), nil
    }

Exponent = ('e' / 'E') IntConstant

Annotations <- LPAR Annotation+ RPAR

Annotation <- Identifier EQUAL Literal ListSeparator?

ConstList  = LBRK v:ConstListItem* RBRK {
	fmt.Println("constlist")
	return NewConstValue("list", toConstValueSlice(v)), nil
}

ConstListItem = v:ConstValue ListSeparator? {
	fmt.Println("ConstListItem", v)
	return v.(*ConstValue), nil
}

ConstMap  = LCUR v:ConstMapItem* RCUR {
	return NewConstValue("map", toConstValueSlice(v)), nil
}

ConstMapItem = key:ConstValue COLON value:ConstValue ListSeparator? {
	return NewMapConstValue(key.(*ConstValue), value.(*ConstValue)), nil
}

EscapeLiteralChar = '\\' ["'] {
	return string(c.text), nil
}

Literal = l:(Literal1 / Literal2) {
	return l, nil
}

Literal1 = Skip '"' t:(EscapeLiteralChar / !'"' .)* '"' Indent* {
	strs := toStringSlice(t)
	return strings.Join(strs, ""), nil
}
Literal2 = Skip "'" t:(EscapeLiteralChar / !"'" .)* "'" Indent* {
	strs := toStringSlice(t)
	return strings.Join(strs, ""), nil
}

StructIdentifier = id:Identifier {
	return id.(*Identifier), nil
} / %{errIdentifier}

Identifier = Skip id:IdentifierToken Indent* {
	return id.(*Identifier), nil
}

IdentifierToken = Letter ( Letter / Digit / '.' )* {
	return NewIdentifier(string(c.text), c.pos), nil
} 

ListSeparator = Skip (',' / ';') Indent*

Letter = [A-Z] / [a-z] / '_' {
	return string(c.text), nil
}
LetterOrDigit = [a-z] / [A-Z] / [0-9] / [_$] {
	return string(c.text), nil
}

Digit = [0-9] {
	return string(c.text), nil
}

ReservedComments = Skip 
ReservedEndLineComments = SkipLine

Skip = comments:(Space / Comment)* {
	return strings.Join(toStringSlice(comments), "\n"), nil
}
SkipLine = comments:(Indent / Comment)* {
	return strings.Join(toStringSlice(comments), "\n"), nil
}

Space = (Indent / CarriageReturnLineFeed)+ {
	return "", nil
}
Indent = [ \t\v] {
	return "", nil
}
CarriageReturnLineFeed = [\r\n]

Comment = v:(LongComment / LineComment / UnixComment) {
	return v.(string), nil
}
LongComment = "/*" comment:LongCommentMatch "*/" {
	return comment.(string), nil
}
LongCommentMatch = (!"*/" .)* {
	return string(c.text), nil
}

LineComment = "//" comment:LineCommentMatch {
	return comment.(string), nil
}
LineCommentMatch = (![\r\n] .)* {
	return string(c.text), nil
}

UnixComment = '#' comment:UnixCommentMatch {
	return comment.(string), nil
}
UnixCommentMatch = (![\r\n] .)*  {
	return string(c.text), nil
}

BOOL        = Skip t:BOOLToken        !LetterOrDigit  Indent* {
	return t.(*TypeName), nil
}
BOOLToken  = "bool" {
	return NewTypeName(string(c.text), c.pos), nil
}

BYTE        = Skip t:BYTEToken        !LetterOrDigit  Indent* {
	return t.(*TypeName), nil
}
BYTEToken = "byte" {
	return NewTypeName(string(c.text), c.pos), nil
}

I8          = Skip t:I8Token          !LetterOrDigit  Indent* {
	return t.(*TypeName), nil
}
I8Token = "i8" {
	return NewTypeName(string(c.text), c.pos), nil
}


I16         = Skip t:I16Token         !LetterOrDigit  Indent* {
	return t.(*TypeName), nil
}
I16Token = "i16" {
	return NewTypeName(string(c.text), c.pos), nil
}

I32         = Skip t:I32Token         !LetterOrDigit  Indent* {
	return t.(*TypeName), nil
}
I32Token = "i32" {
	return NewTypeName(string(c.text), c.pos), nil
}

I64         = Skip t:I64Token         !LetterOrDigit  Indent* {
	return t.(*TypeName), nil
}
I64Token = "i64" {
	return NewTypeName(string(c.text), c.pos), nil
}

DOUBLE      = Skip t:DOUBLEToken      !LetterOrDigit  Indent* {
	return t.(*TypeName), nil
}
DOUBLEToken = "double" {
	return NewTypeName(string(c.text), c.pos), nil
}

STRING      = Skip t:STRINGToken      !LetterOrDigit  Indent* {
	return t.(*TypeName), nil
}
STRINGToken = "string" {
	return NewTypeName(string(c.text), c.pos), nil
}

BINARY      = Skip t:BINARYToken      !LetterOrDigit  Indent* {
	return t.(*TypeName), nil
}
BINARYToken = "binary" {
	return NewTypeName(string(c.text), c.pos), nil
}

CONST       = Skip t:CONSTToken         !LetterOrDigit  Indent* {
	return t.(*TypeName), nil
}
CONSTToken = "const" {
	return NewTypeName(string(c.text), c.pos), nil
}

ONEWAY      = Skip t:ONEWAYToken        !LetterOrDigit  Indent* {
	return t.(*TypeName), nil
}
ONEWAYToken = "oneway" {
	return NewTypeName(string(c.text), c.pos), nil
}

TYPEDEF     = Skip "typedef"       !LetterOrDigit  Indent* {
	return "typedef", nil
}
MAP         = Skip t:MAPToken           !LetterOrDigit  Indent* {
	return t.(*TypeName), nil
}
MAPToken = "map" {
	return NewTypeName(string(c.text), c.pos), nil
}

SET         = Skip t:SETToken           !LetterOrDigit  Indent* {
	return t.(*TypeName), nil
}
SETToken = "set" {
	return NewTypeName(string(c.text), c.pos), nil
}

LIST        = Skip t:ListToken          !LetterOrDigit  Indent* {
	return t.(*TypeName), nil
}
ListToken = "list" {
	return NewTypeName(string(c.text), c.pos), nil
}

VOID        = Skip "void"          !LetterOrDigit  Indent* {
	return "void", nil
}
THROWS      = Skip "throws"        !LetterOrDigit  Indent* {
	return "throws", nil
}
EXCEPTION   = Skip "exception"     !LetterOrDigit  Indent* {
	return "exception", nil
}
EXTENDS     = Skip "extends"       !LetterOrDigit  Indent* {
	return "extends", nil
}
SERVICE     = Skip "service"       !LetterOrDigit  Indent* {
	return "service", nil
}
STRUCT      = Skip "struct"        !LetterOrDigit  Indent* {
	return "struct", nil
}
UNION       = Skip "union"         !LetterOrDigit  Indent* {
	return "union", nil
}
ENUM        = Skip "enum"          !LetterOrDigit  Indent* {
	return "enum", nil
}
INCLUDE     = Skip "include"       !LetterOrDigit  Indent* {
	return "include", nil
}
CPPINCLUDE  = Skip "cpp_include"   !LetterOrDigit  Indent* {
	return "cpp_include", nil
}
NAMESPACE   = Skip "namespace"     !LetterOrDigit  Indent* {
	return "namespace", nil
}
CPPTYPE     = Skip "cpp_type"      !LetterOrDigit  Indent* {
	return "cpp_type", nil
}
LBRK        = Skip "["     Indent* {
	return "[", nil
}
RBRK        = Skip "]"     Indent* {
	return "]", nil
}
LCUR       = Skip t:LCURToken     Indent* {
	return t.(string), nil
}
RCUR       = Skip t:RCURToken     Indent* {
	return t.(string), nil
}
LCURToken = "{" {
	return string(c.text), nil
}
RCURToken = "}" {
	return string(c.text), nil
} / %{errRCUR}
EQUAL       = Skip "="     Indent* {
	return "=", nil
}
LPOINT      = Skip "<"     Indent* {
	return "<", nil
}
RPOINT      = Skip ">"     Indent* {
	return ">", nil
}
COMMA       = Skip ","     Indent* {
	return ",", nil
}
LPAR        = Skip "("     Indent* {
	return "(", nil
}
RPAR        = Skip ")"     Indent* {
	return ")", nil
}
COLON       = Skip ":"     Indent* {
	return ":", nil
}

DefinitionStart = "struct"

ErrField = #{
	return InvalidStructFieldError
} ( !(Field / (Skip '}' Indent*) / STRUCT ) . )* {
	return NewField("", "", 0, nil, nil, nil, nil), nil
}

ErrStructIdentifier = #{
	return InvalidStructIdentifierError
} ( !'{' .)* { // struct identifier 异常，consume 掉异常字符直到出现 '{' 为止
	t := NewIdentifier("", c.pos)
	t.BadNode = true

	return t, nil
} // 构造 identifier 的 badnode

ErrStructRCUR = #{
	return InvalidStructBlockRCURError
} ( !STRUCT .)* { // 缺少 '}'，消费异常字符直到出现下一个 struct。TODO(jpf): 后面会加入 typedef 等定义，需要扩展补充
	return "?", nil
}

ErrStructLCUR = #{
	return InvalidStructBlockLCURError
} ( !'}' .)* { // 缺少 '{'，消费异常字符直到出现下一个 Field 或者 '}'
	return "?", nil
}
